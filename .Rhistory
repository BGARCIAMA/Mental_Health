#| echo: false
#| label: librerias
import numpy as np
import pandas as pd
import matplotlib.pylab as plt
import seaborn as sns
from mpl_toolkits.axes_grid1.inset_locator import inset_axes
sns.set_palette("pastel")
import warnings
warnings.filterwarnings('ignore')
#| echo: false
#| label: info
train = pd.read_csv('data/train.csv')
test = pd.read_csv("data/test.csv")
# rename columns
train.columns = [col.lower().replace(" ","_") for col in train.columns]
test.columns = [col.lower().replace(" ","_") for col in test.columns]
train.info()
#| echo: false
train.describe().round(2).style.format(precision=2)
#| echo: false
train.describe().round(2).style.format(precision=2)
#| echo: false
#| label: info
train = pd.read_csv('data/train.csv')
test = pd.read_csv("data/test.csv")
# rename columns
train.columns = [col.lower().replace(" ","_") for col in train.columns]
test.columns = [col.lower().replace(" ","_") for col in test.columns]
train_info = train.info()
info_df = pd.DataFrame(train_info)
#| echo: false
#| label: info
train = pd.read_csv('data/train.csv')
test = pd.read_csv("data/test.csv")
# rename columns
train.columns = [col.lower().replace(" ","_") for col in train.columns]
test.columns = [col.lower().replace(" ","_") for col in test.columns]
train_info = train.info()
info_df = pd.DataFrame(train_info)
info_df
reticulate::repl_python()
# Crear una matriz de puntos (latitud, longitud)
set.seed(42)
n <- 100000
r <- 500
points <- data.frame(
x = runif(n, 0, 10000),
y = runif(n, 0, 10000)
)
# Punto de interés
x0 <- c(5000, 5000)
# Asignar celdas
cell_size <- r
points$cell_x <- floor(points$x / cell_size)
points$cell_y <- floor(points$y / cell_size)
# Celda del punto de interés
cell_x0 <- floor(x0[1] / cell_size)
cell_y0 <- floor(x0[2] / cell_size)
# Filtrar puntos en celdas adyacentes
candidate_points <- points %>%
filter(
cell_x >= cell_x0 - 1 & cell_x <= cell_x0 + 1,
cell_y >= cell_y0 - 1 & cell_y <= cell_y0 + 1
)
# Asignar celdas
cell_size <- r
points$cell_x <- floor(points$x / cell_size)
points$cell_y <- floor(points$y / cell_size)
# Celda del punto de interés
cell_x0 <- floor(x0[1] / cell_size)
cell_y0 <- floor(x0[2] / cell_size)
# Filtrar puntos en celdas adyacentes
candidate_points <- points |>
filter(
cell_x >= cell_x0 - 1 & cell_x <= cell_x0 + 1,
cell_y >= cell_y0 - 1 & cell_y <= cell_y0 + 1
)
# Crear una matriz de puntos (latitud, longitud)
set.seed(42)
n <- 100000
r <- 500
points <- data.frame(
x = runif(n, 0, 10000),
y = runif(n, 0, 10000)
)
# Punto de interés
x0 <- c(5000, 5000)
# Asignar celdas
cell_size <- r
points$cell_x <- floor(points$x / cell_size)
points$cell_y <- floor(points$y / cell_size)
# Celda del punto de interés
cell_x0 <- floor(x0[1] / cell_size)
cell_y0 <- floor(x0[2] / cell_size)
# Filtrar puntos en celdas adyacentes
candidate_points <- points |>
filter(
cell_x >= cell_x0 - 1 & cell_x <= cell_x0 + 1,
cell_y >= cell_y0 - 1 & cell_y <= cell_y0 + 1
)
# Crear una matriz de puntos (latitud, longitud)
set.seed(42)
n <- 100000
r <- 500
points <- data.frame(
x = runif(n, 0, 10000),
y = runif(n, 0, 10000)
)
# Verificar que el dataframe tiene las columnas correctas
str(points)  # Verificar estructura de datos
# Punto de interés
x0 <- c(5000, 5000)
# Asignar celdas
cell_size <- r
points <- points |>
mutate(
cell_x = floor(x / cell_size),
cell_y = floor(y / cell_size)
)
# Crear una matriz de puntos (latitud, longitud)
library(dplyr)
# Crear una matriz de puntos (latitud, longitud)
library(dplyr)
set.seed(42)
n <- 100000
r <- 500
points <- data.frame(
x = runif(n, 0, 10000),
y = runif(n, 0, 10000)
)
# Verificar que el dataframe tiene las columnas correctas
str(points)  # Verificar estructura de datos
# Punto de interés
x0 <- c(5000, 5000)
# Asignar celdas
cell_size <- r
points <- points |>
mutate(
cell_x = floor(x / cell_size),
cell_y = floor(y / cell_size)
)
# Verificar que las columnas cell_x y cell_y se generaron correctamente
head(points)
# Celda del punto de interés
cell_x0 <- floor(x0[1] / cell_size)
cell_y0 <- floor(x0[2] / cell_size)
# Filtrar puntos en celdas adyacentes
candidate_points <- points |>
filter(
cell_x >= cell_x0 - 1 & cell_x <= cell_x0 + 1,
cell_y >= cell_y0 - 1 & cell_y <= cell_y0 + 1
)
# Verificar los puntos candidatos
head(candidate_points)
# Calcular distancia euclidiana solo para los puntos candidatos
candidate_points <- candidate_points |>
mutate(distance = sqrt((x - x0[1])^2 + (y - x0[2])^2)) |>
filter(distance <= r)
# Resultado: puntos dentro del radio r
result <- candidate_points
print(result)
reticulate::repl_python()
reticulate::repl_python()
reticulate::repl_python()
